<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fleet Management</title>

    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="Descrptions needs to be added here" />
    <meta name="keywords" content="Microsoft maps, map, gis, API, SDK, animate, animation, symbols, pushpins, markers, pins, line, linestring, polyline" />
    <meta name="author" content="Microsoft Azure Maps" />

    <!-- Add references to the Azure Maps Map control JavaScript and CSS files. -->
    <link rel="stylesheet" href="https://atlas.microsoft.com/sdk/javascript/mapcontrol/2/atlas.min.css" type="text/css" />
    <script src="https://atlas.microsoft.com/sdk/javascript/mapcontrol/2/atlas.min.js"></script>

    <script type='text/javascript'>
	
        var map, pin, datasource,marker,popup;
        var animationTime = 5000;
        var animation;
				
        //Create an array of points to define a path to animate along.
        var path = [
           [-122.34758, 47.62155],
           [-122.34764, 47.61859],
           [-122.33787, 47.61295],
           [-122.34217, 47.60964]

        ];

        //Data points for a path, could be from a GPS device.
        var points = [
            { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.34758, 47.62155] }, properties: { speed: 55 , risk : "low"} },
            { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.34764, 47.61859] }, properties: { speed: 57  ,risk : "low"} },
            { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.33787, 47.61295] }, properties: { speed: 70 ,risk : "high"} },
            { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.34217, 47.60964] }, properties: { speed: 60 , risk : "medium"} },
        ];
		
        function GetMap() {
            //Initialize a map instance.
            map = new atlas.Map('myMap', {
                center: [-122.345, 47.615],
                zoom: 14,
				style: 'road',
                view: 'Auto',
               //Set the language of the map.
                language: 'en-US',
				
				//Add your Azure Maps subscription key to the map SDK. Get an Azure Maps key at https://azure.com/maps
                authOptions: {
                    authType: 'subscriptionKey',
                    subscriptionKey: 'x4OKrH-wlKiAZgo6GMH8NECEN7hlZgorUcgkPy1xQaU'
                }
            });
			
            //Wait until the map resources are ready.
            map.events.add('ready', function () {


                //Create a data source and add it to the map.
                datasource = new atlas.source.DataSource(null, {
                    cluster: true
                });
                map.sources.add(datasource);

                //Add sample data.
				datasource.add([
                    new atlas.data.Feature(new atlas.data.Point([-122.34764, 47.61859]), {
                        title: 'COP-1',
                        message: 'Live feed of the Vehicle',
						content: '<iframe style="margin:10px" width="400" height="200" src="https://channel9.msdn.com/Shows/Internet-of-Things-Show/Azure-Maps-intro-for-developers/player" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>',
						pixelOffset: [0, 0],
                        url: 'https://aka.ms/AzureMapsSamples',
                        email: 'info@microsoft.com',
                        popupTemplate: {
                            detectHyperlinks: true
                        }
                    }),

                    <!-- new atlas.data.Feature(new atlas.data.Point([-122.33787, 47.61295]), { -->
                        <!-- title: 'COP-2 - PropertyInfo', -->
                        <!-- createDate: new Date(), -->
                        <!-- dateNumber: 1569880860542, -->
                        <!-- url: 'https://aka.ms/AzureMapsSamples', -->
                        <!-- email: 'info@microsoft.com', -->
                        <!-- popupTemplate: { -->
                            <!-- content: [ -->
                                <!-- { -->
                                    <!-- propertyPath: 'createDate', -->
                                    <!-- label: 'Created Date' -->
                                <!-- }, -->
                                <!-- { -->
                                    <!-- propertyPath: 'dateNumber', -->
                                    <!-- label: 'Formatted date from number', -->
                                    <!-- dateFormat: { -->
                                        <!-- weekday: 'long', -->
                                        <!-- year: 'numeric', -->
                                        <!-- month: 'long', -->
                                        <!-- day: 'numeric', -->
                                        <!-- timeZone: 'UTC', -->
                                        <!-- timeZoneName: 'short' -->
                                    <!-- } -->
                                <!-- }, -->
                                <!-- { -->
                                    <!-- propertyPath: 'url', -->
                                    <!-- label: 'Code samples', -->
                                    <!-- hideLabel: true, -->
                                    <!-- hyperlinkFormat: { -->
                                        <!-- lable: 'Go to code samples!', -->
                                        <!-- target: '_blank' -->
                                    <!-- } -->
                                <!-- }, -->
                                <!-- { -->
                                    <!-- propertyPath: 'email', -->
                                    <!-- label: 'Email us', -->
                                    <!-- hideLabel: true, -->
                                    <!-- hyperlinkFormat: { -->
                                        <!-- target: '_blank', -->
                                        <!-- scheme: 'mailto:' -->
                                    <!-- } -->
                                <!-- } -->
                            <!-- ] -->
                        <!-- } -->
                    <!-- }), -->

                    new atlas.data.Feature(new atlas.data.Point([-122.34217, 47.60964]), {
                        title: 'COP-3',
                        value1: 1.2345678,
                        value2: {
                            subValue: 'Pizza'
                        },
                        arrayValue: [3, 4, 5, 6],
                        imageLink: 'https://azuremapscodesamples.azurewebsites.net/common/images/Pike_Market.jpg',
                        popupTemplate: {
                            content: [
                                'This template has two pieces of content; a string template with placeholders and a array of property info which renders a full width image.<br/><br/> - Value 1 = {value1}<br/> - Value 2 = {value2/subValue}<br/> - Array value [2] = {arrayValue/2}',
                                [
                                    {
                                        propertyPath: 'imageLink',
                                        label: 'COP',
                                        hideImageLabel: true,
                                        hyperlinkFormat: {
                                            isImage: true
                                        }
                                    }
                                ]
                            ],
                            numberFormat: {
                                maximumFractionDigits: 2
                            }
                        }
                    }),
                ]);

                //Add a layer for rendering point data as symbols.
				var layer = new atlas.layer.BubbleLayer(datasource);
                map.layers.add(layer);
				
                //Create a popup but leave it closed so we can update it and display it later.
				popup = new atlas.Popup();

                //Add a click event to the symbol layer.
                map.events.add('click', layer, showPopup);



			/* Construct and add a compass control*/
			  var compassControl = new atlas.control.CompassControl();
			  map.controls.add(compassControl, {
				position: "bottom-right"
			  });

			  /* Construct and add a zoom control*/
			  var zoomControl = new atlas.control.ZoomControl();
			  map.controls.add(zoomControl, {
				position: "bottom-right"
			  });

			  /* Construct and add a pitch control*/
			  var pitchControl = new atlas.control.PitchControl();
			  map.controls.add(pitchControl, {
				position: "bottom-right"
			  });

			  /* Construct and add a style control*/
			  var styleControl = new atlas.control.StyleControl();
			  map.controls.add(styleControl, {
			  position: "bottom-right"
			  })
			

                //Load a custom image icon into the map resources.
                map.imageSprite.add('arrow-icon', './Common/images/icons/truck.png').then(function () {
				 
				 //Create a data source and add it to the map.   --added -1
                datasource = new atlas.source.DataSource(null, {
                    lineMetrics: true   //Enable line metrics on the data source. This is needed to enable support for strokeGradient.
                });
				 
                 map.sources.add(datasource);	
				 //datasource.add(points);
                //Create a line from the points and add it to the data source.
                var line = createLineFrom(points);
                datasource.add(line);
				
				//Calculate a color gradient expression based on the speed of each data point.
                var speedGradient = calculateGradientExpression(points, line);

                //Create a line layer and pass in a gradient expression for the strokeGradient property.
                map.layers.add(new atlas.layer.LineLayer(datasource, null, {
                    strokeWidth: 4,
                    strokeGradient: speedGradient
                }));

                //Create a layer to render each data point along the path.
                var pointLayer = new atlas.layer.SymbolLayer(datasource, null, {
                    //Only render point data in this layer, not the points of the line.
                    filter: ['==', ['geometry-type'], 'Point']
                });
	

                //Open/close the popup when hovered.
                map.events.add('mousemove', pointLayer, pointClicked);
                map.events.add('mouseout', pointLayer, closePopup);

                map.layers.add(pointLayer);
				   
                 //Create a layer to render a symbol which we will animate.
                    map.layers.add(new atlas.layer.SymbolLayer(datasource, null, {
                        iconOptions: {
                            //Pass in the id of the custom icon that was loaded into the map resources.
                            image: 'arrow-icon',
                            //Anchor the icon to the center of the image.
                            anchor: 'center',
                            //Rotate the icon based on the rotation property on the point data.
                            rotation: ['get', 'rotation'],
                            //Have the rotation align with the map.
                            rotationAlignment: 'map',
                            //For smoother animation, ignore the placement of the icon. This skips the label collision calculations and allows the icon to overlap map labels. 
                            ignorePlacement: true,
                            //For smoother animation, allow symbol to overlap all other symbols on the map.
                            allowOverlap: true    
                        },
                        textOptions: {
                            //For smoother animation, ignore the placement of the text. This skips the label collision calculations and allows the text to overlap map labels.
                            ignorePlacement: true,
                            //For smoother animation, allow text to overlap all other symbols on the map.
                            allowOverlap: true  
                        },
                        //Only render Point or MultiPoints in this layer.    
                        filter: ['any', ['==', ['geometry-type'], 'Point'], ['==', ['geometry-type'], 'MultiPoint']] 
                    }));
                    //Create a pin and wrap with the shape class and add to data source.
                    pin = new atlas.Shape(new atlas.data.Feature(new atlas.data.Point(path[0]), {
                        rotation: 180
                    }));
                    datasource.add(pin);
                    animation = new animations.PathAnimation(path, function (position, heading, progress) {
                        //Update the rotation of the symbol. 
                        pin.setProperties({
                            rotation: heading
                        });
                        //Update the symbols coordinates.
                        pin.setCoordinates(position);
                        if (document.getElementById('followSymbol').checked) {
                            map.setCamera({
                                center: position,
                                bearing: heading,
                                pitch: 45,
                                zoom: 15
                            });
                        }
                    }, animationTime);
                });
				
			   	
				var marker = new atlas.HtmlMarker({
				color: 'DodgerBlue',
				text: 'TT-1',
				position: [-122.34758, 47.62155],
				popup: new atlas.Popup({
				content: '<div style="padding:10px"><font color="white">Driver Name : BUNJONG BORIBOON ,<br>TT Number : KA 01 EU0073, <br>Fleet_Risk_Assesment :</font><font color="yellow"> Medium</font> </div>',
				pixelOffset: [0, -30],
				fillColor: 'rgba(0,0,0,0.4)',
				draggable: true

					})
				});

				map.markers.add(marker);

				//Add a click event to toggle the popup.
				map.events.add('click',marker, () => {
					marker.togglePopup();
				});
				
            });
        }
		
         function showPopup(e) {
            if (e.shapes && e.shapes.length > 0) {
                var properties = e.shapes[0].getProperties();

                popup.setOptions({
                    //Update the content of the popup.
                    content: atlas.PopupTemplate.applyTemplate(properties, properties.popupTemplate),

                    //Update the position of the popup with the pins coordinate.
                    position: e.shapes[0].getCoordinates()
                });

                //Open the popup.
                popup.open(map);
            }
        }

        function updateLanguage() {
            var langOptions = document.getElementById('langOptions');
            var lang = langOptions.options[langOptions.selectedIndex].value;
            //Update the language of the map instance.
            map.setStyle({
                language: lang
            });
        }
		
		
		        function createLineFrom(points) {
            var coords = [];
            for (var i = 0; i < points.length; i++) {
                coords.push(points[i].geometry.coordinates);
            }
            return new atlas.data.LineString(coords);
        }

        function calculateGradientExpression(points, line) {
            var exp = [
                'interpolate',  //This will cause the colors from each data point to create a gradient between points.
                ['linear'],
                ['line-progress']
            ];

            //Get the total length of the path.
            var totalLength = atlas.math.getLengthOfPath(line);

            //The line progress will be a fraction of the total length of the path,
            //so we can calculate the line progress value of each data point and set the color accordingly.
            var progress = 0;

            for (var i = 0; i < points.length; i++) {
                //The line progress value is a value between 0 and 1. 
                //Taking the travelled distance and dividing it by the total distance of the path, will give us the line progress value.
                exp.push(progress / totalLength);

                //Add our business logic on how a data point should be colored based on the speed.

                if (points[i].properties.speed <= 60) {
                    exp.push('green');
                } else if (points[i].properties.speed < 70) {
                    exp.push('yellow');
                } else {
                    exp.push('red');
                }

                if (i < points.length - 1) {
                    progress += atlas.math.getDistanceTo(points[i], points[i + 1]);
                }
            }

            return exp;
        }

        function pointClicked(e) {
            var prop = e.shapes[0].getProperties();

            popup.setOptions({
                //content: '<div style="padding:10px;">Speed: ' + prop.speed + 'mph ,'+ prop.risk +' </div>',
				content: '<div style="padding:10px;">Speed: ' + 60 + 'mph ,'+ 'Risk :' + 'Medium' +' </div>',
                position: e.shapes[0].getCoordinates()
            });

            popup.open(map);
        }

        function closePopup() {
            popup.close();
        }
    	
		
        function play() {
            if (animation) {
                animation.play();
            }
        }
        function pause() {
            if (animation) {
                animation.pause();
            }
        }
        function stop() {
            if (animation) {
                animation.stop();
            }
        }
        var animations = (function () {
            var self = this;
            var _delay = 30; //30 = 33.3 frames per second, 16 = 62.5 frames per second
            this.PathAnimation = function (path, intervalCallback, duration) {
                /// <summary>This class extends from the BaseAnimation class and cycles through a set of positions over a period of time, calculating mid-point positions along the way.</summary>
                /// <param name="path" type="Position[]">An array of positions to cycle through.</param>
                /// <param name="intervalCallback" type="Function">A function that is called when a frame is to be rendered. This callback function recieves three values; current position, heading, progress.</param>
                /// <param name="duration" type="Number">Length of time in ms that the animation should run for. Default is 1000 ms.</param>
                var _totalDistance = 0,
                    _intervalLocs = [path[0]],
                    _intervalHeadings = [],
                    _intervalIdx = [0],
                    _frameCount = Math.ceil(duration / _delay), idx;
                var progress, dlat, dlon;
                //Calcualte the total distance along the path in degrees.
                for (var i = 0; i < path.length - 1; i++) {
                    dlat = (path[i + 1][1] - path[i][1]);
                    dlon = (path[i + 1][0] - path[i][0]);
                    _totalDistance += Math.sqrt(dlat * dlat + dlon * dlon);
                }
                //Pre-calculate step points for smoother rendering.
                for (var f = 0; f < _frameCount; f++) {
                    progress = (f * _delay) / duration;
                    var travel = progress * _totalDistance;
                    var alpha;
                    var dist = 0;
                    var dx = travel;
                    for (var i = 0; i < path.length - 1; i++) {
                        dlat = (path[i + 1][1] - path[i][1]);
                        dlon = (path[i + 1][0] - path[i][0]);
                        alpha = Math.atan2(dlat * Math.PI / 180, dlon * Math.PI / 180);
                        dist += Math.sqrt(dlat * dlat + dlon * dlon);
                        if (dist >= travel) {
                            idx = i;
                            break;
                        }
                        dx = travel - dist;
                    }
                    if (dx != 0 && idx < path.length - 1) {
                        dlat = dx * Math.sin(alpha);
                        dlon = dx * Math.cos(alpha);
                        var dest = [path[idx][0] + dlon, path[idx][1] + dlat];
                        _intervalLocs.push(dest);
                        _intervalHeadings.push(atlas.math.getHeading(path[idx], dest));
                        _intervalIdx.push(idx);
                    }
                }
                //Ensure the last location is the last position in the path.
                _intervalHeadings.push(atlas.math.getHeading(_intervalLocs[_intervalLocs.length - 1], path[path.length - 1]));
                _intervalLocs.push(path[path.length - 1]);
                _intervalIdx.push(path.length - 1);
                if (_intervalHeadings.length < _intervalLocs.length) {
                    _intervalHeadings.push(_intervalHeadings[_intervalHeadings.length - 1]);
                }
                return new self.BaseAnimation(
                    function (progress, frameIdx) {
                        if (intervalCallback) {
                            intervalCallback(_intervalLocs[frameIdx], _intervalHeadings[frameIdx], progress);
                        }
                    }, duration);
            }
            this.BaseAnimation = function (renderFrameCallback, duration) {
                /// <summary>A base class that can be used to create animations that support play, pause and stop.</summary>
                /// <param name="renderFrameCallback" type="Function">A function that is called when a frame is to be rendered. This function recieves two values; progress and frameIdx.</param>
                /// <param name="duration" type="Number">Length of time in ms that the animation should run for. Default is 1000 ms.</param>
                var _timerId,
                    frameIdx = 0,
                    _isPaused = true;
                //Varify value
                duration = (duration && duration > 0) ? duration : 1000;
                this.play = function () {
                    if (renderFrameCallback) {
                        _isPaused = false;
                        if (!_timerId) {
                            _timerId = setInterval(function () {
                                if (!_isPaused) {
                                    var progress = (frameIdx * _delay) / duration;
                                    renderFrameCallback(progress, frameIdx);
                                    if (progress >= 1) {
                                        reset();
                                    }
                                    frameIdx++;
                                }
                            }, _delay);
                        }
                    }
                };
                this.isPlaying = function () {
                    return !_isPaused;
                };
                this.pause = function () {
                    _isPaused = true;
                };
                this.stop = function () {
                    reset();
                };
                function reset() {
                    if (_timerId != null) {
                        clearInterval(_timerId);
                        _timerId = null;
                    }
                    frameIdx = 0;
                    renderFrameCallback(0, frameIdx);
                    _isPaused = true;
                }
            }
            return self;
        })();
    </script>

    <style>
        #myMap {
            position: relative;
            width: 100%;
            min-width:290px;
            height: 550px;
        }
        .controlPanel {
            position:absolute;
            top:15px;
            left:15px;
            border-radius:5px;
            padding:5px;
            background-color:white;
        }
    </style>
	
</head>

	<body onload="GetMap()">
		<div id="myMap"></div>
		<div class="controlPanel">

	   <select>
		<option selected="selected">TT-1</option>
		<option value="TT-2">TT-2</option>
		<option value="TT-3">TT-3</option>
	   </select> 
			<input type="button" value="Track TT" onclick="play()" />
			<input type="button" value="Pause" onclick="pause()" />
			<input type="button" value="Stop" onclick="stop()" />
			<br/>
			Follow: <input id="followSymbol" type="checkbox"/>
		</div>



    <div style="clear:both;padding-top:10px;">

        Language:

        <select id="langOptions" onchange="updateLanguage()">
            <option value="NGT">Neutral Ground Truth (NGT)</option>
            <option value="NGT-Latn">Neutral Ground Truth - Latin exonyms (NGT-Latn)</option>
            <option value="ar">Arabic (ar)</option>
            <option value="bg">Bulgarian (bg)</option>
            <option value="bg-BG">Bulgarian (Bulgaria) (bg-BG)</option>
            <option value="ca-ES">Catalan (Spain) (ca-ES)</option>
            <option value="cs">Czech (cs)</option>
            <option value="cs-CZ">Czech (Czech Republic) (cs-CZ)</option>
            <option value="da">Danish (da)</option>
            <option value="da-DK">Danish (Denmark) (da-DK)</option>
            <option value="nl">Dutch (Netherlands) (nl)</option>
            <option value="nl-NL">Dutch (Netherlands) (nl-NL)</option>
            <option value="en">English (en)</option>
            <option value="en-AU">English (Australia) (en-AU)</option>
            <option value="en-CA">English (Canada) (en-CA)</option>
            <option value="en-GB">English (United Kingdom) (en-GB)</option>
            <option value="en-NZ">English (New Zealand) (en-NZ)</option>
            <option value="en-US" selected="selected">English (United States) (en-US)</option>
            <option value="fi">Finnish (fi)</option>
            <option value="fi-FI">Finnish (Finland) (fi-FI)</option>
            <option value="fr">French (fr)</option>
            <option value="fr-FR">French (France) (fr-FR)</option>
            <option value="de">German (de)</option>
            <option value="de-DE">German (Germany) (de-DE)</option>
            <option value="lt">Lithuanian (lt)</option>
            <option value="lt-LT">Lithuanian (lt-LT)</option>
            <option value="ms-MY">Malay (ms-MY)</option>
            <option value="nb-NO">Norwegian, Bokmal (Norway) (nb-NO)</option>
            <option value="pl">Polish (pl)</option>
            <option value="pl-PL">Polish (Poland) (pl-PL)</option>
            <option value="pt">Portuguese (Brazil) (pt)</option>
            <option value="pt-BR">Portuguese (Brazil) (pt-BR)</option>
            <option value="pt-PT">Portuguese (Portugal) (pt-PT)</option>

        </select>

    </div>


		<fieldset style="width:calc(100% - 30px);min-width:290px;margin-top:10px;">
			<legend><h1 style="font-size:16px">Fleet Tracking management</h1></legend>
			This mockup requeires descprition to be added here ( Work in Progress). 
		</fieldset>
	</body>

</html>
